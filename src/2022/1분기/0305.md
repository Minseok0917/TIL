---
title : TIL 2022.03.05
description : 가상돔 updateElement 구현 완료 
creationDate : 2022.03.05
tags : ['TIL','React','Webpack','Viutal-Dom']
---

# 2022.03.05

오늘은 가상돔을 완성했다.     
문제가 글을 적을려고 해도 Github TIL 의 자동 배포가 안되고 있다.     
Git workflow 에 대해 좀 찾아봐야지 해결 할 수 있을거 같다.    

## 가상돔 완성

### 생성, 삭제
`create` 와 `delete` 부분은 저렇게 써줬다.   
```js
{ // Create, Delete
		const isCreate = !oldNode && newNode;
		const isDelete = oldNode && !newNode;
		if( isCreate ){
			return $container.appendChild(createElement(newNode));
		}
		if(isDelete){
			return $container.removeChild($container.childNodes[childIndex]);
		}
	}
```
### Text 수정
기존에 타입 string 과 number 까지 검사했지만 string 만 검사하게 하고,     
number 부분은 React.createElement 부분에서 string 으로 바꿔준다.    
string 과 number 다 보니깐 텍스트 값이 2개가 생겨있었다.  
```js
// dom.js
	{ // TextNode
		const oldNodeType = typeof oldNode;
		const newNodeType = typeof newNode;
		const isTextNode = ( oldNodeType === 'string'  && newNodeType === 'string' );
		if( isTextNode ){
			if( oldNode === newNode ) return;
			$container.textContent = newNode;
			return;
		}
	}
```

```js
// react.js 
function h(tag,config,children){
	const isTextNode = children.every( text =>  ['string','number'].includes(typeof text));
	if( isTextNode ){
		children = [children.join('')];
	}
	return {
		tag,
		config,
		children
	}
}
```

### 태그 변경
서로 태그가 일치하지 않을 때 기존 element 를 새로운 element 로 바꿈.     
updateAttributes 에선 newNode 에 있는 속성값을 추가해준다.
```js
	{ // Node
		{  // Replace
			const isReplace = oldNode.tag !== newNode.tag;
			if( isReplace ){
				return $container.replaceChild(createElement(newNode),$container.childNodes[childIndex]);
			}
		}
		updateAttributes($container,oldNode,newNode,childIndex);
		{ // Recursion
			const max = Math.max(
				oldNode.children.length,
				newNode.children.length
			);
			for(let idx=0; idx<max; idx++){
				updateElement(
					$container.childNodes[childIndex],
					oldNode.children[idx],
					newNode.children[idx],
					idx
				);
			}
		}
	}


function updateAttributes($container, oldNode, newNode,childIndex){
	Object.entries(oldNode.config || {}).forEach( ([key,value]) => { // 이전 속성 값 초기화
		$container.childNodes[childIndex][key] = '';

	Object.entries(newNode.config || {}).forEach( ([key,value]) => { // 현재 속성 값 적용
		$container.childNodes[childIndex][key] = value;
} 
```

### Component Array
jsx 에서 for 렌더링을 하려고 할 때 `{ [].map(func) }` 이런형식으로 쓴다.    
이게 트랜스파일링되면 배열 값으로 넘어가 있기 때문에    
아래 처럼 추가로 등록해줘야 한다.
```js
	if( Array.isArray(newNode) ){
		const max = Math.max(
			oldNode.length,
			newNode.length
		);
		for(let i=0; i<max; i++){
			updateElement(
				$container,
				oldNode[i],
				newNode[i],
				childIndex+i
			);
		}
		return;
	}
```