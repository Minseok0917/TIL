# 2022.03.04


## LeetCode-1408 
친구랑 놀다가 어쩌다 보니 알고리즘을 풀게 되었음. 

문제 자체가 특정배열에 단어가 존재하는지에 대한 검사를 해서 존재하는 단어만 return 해 주는 형식이었다.     
처음에는 풀이방식을 단어 길이가 작은 순으로 정렬하였다.   
그리고 단어 순으로 2중 for문을 돌리고 includes 로 값이 존재할 경우      
result 배열에 넣어주고 중복되는건 `new Set` 으로 해주었다.    
```js
/*
	Input: words = ["mass","as","hero","superhero"]
	Output: ["as","hero"]
*/
var stringMatching = function(words) {
    const sortArray = words.sort( (a,b) => a.length - b.length ); 
    const sortLength = sortArray.length;
    let result = [];
    for(let i=0; i <  sortLength; i++){
        const word = words[i];
        for(let j=i+1; j <  sortLength; j++){
            if( words[j].includes(word) ){
                result.push(word);
            }
        }
    }
    return [...new Set(result)];
};
```
그리고 친구랑 이야기 하다 LeetCode에서는 다른 사람 풀이를 볼 수 있다.     
시간에 따른 그래프로 자기 자신의 코드가 어느정도 빠른지 볼 수 있다. `(속도, 메모리 사용량) 등 가능`        
제일 잘 짠 사람의 코드를 보니깐 경이로웠다.    
배열을 `join(' ')` 으로 해서 `indexOf` 와 `lastIndexOf` 로 위치를 구분해서    
중복검사 또는 위치 검사를 완벽하게 한거에 놀라움을 금치 못했다.  
```js
var stringMatching = function(words) {
    let str = words.join(' '); // 배열 데이터를 텍스트로 합침
    let result = []
    for(let word of words){
    	/*
    		첫 글자 Index로 구하고 , 마지막 Index 랑 비교해서 
    		Index 가 동일하면 단어가 하나 밖에 없는거다 
    		그래서 일치 하지 않을 경우 result 에 push 해준다.
    	*/
        if( str.indexOf(word) != str.lastIndexOf(word) ){ 
            result.push(word);
        }
    }

    return result;
};
```
가상돔을 하려다 어쩌다 보니 알고리즘을 풀게 됬는데 알고리즘이 매우 재밌엇다. : )